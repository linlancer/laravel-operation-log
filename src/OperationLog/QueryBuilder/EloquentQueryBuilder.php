<?php
/**
 * Created by PhpStorm.
 * User: $_s
 * Date: 2020/5/12
 * Time: 11:28
 */

namespace LinLancer\Laravel\OperationLog\QueryBuilder;


use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Pagination\Paginator;
use LinLancer\Laravel\EloquentModel;
use LinLancer\Laravel\ModelFormArray;
use LinLancer\Laravel\OperationLogger;

class EloquentQueryBuilder extends Builder
{
    const TYPE_IN = 'In';

    const TYPE_RAW = 'raw';

    const TYPE_IN_RAW = 'InRaw';

    private $originalGroups = [];

    private $fromPaginator = false;

    private $totalCount = 0;

    public function update(array $values)
    {
        $model = $this->getModel();
        if ($model instanceof OperationLogger && $model->exists === false) {
            $models = $this->getModels();
            $this->beforeUpdate($models);
        }
        $result = parent::update($values); // TODO: Change the autogenerated stub
        if ($model instanceof OperationLogger && $model->exists === false) {
            $models = $this->getModels();
            $this->afterUpdate($models);
        }

        return $result;
    }

    public function beforeUpdate(array $models)
    {
        /**
         * @var EloquentModel $model
         */
        foreach ($models as $model) {
            $this->originalGroups[] = $model->getOriginal();
        }
    }

    public function afterUpdate(array $models)
    {
        /**
         * @var EloquentModel $model
         */
        foreach ($models as $k => $model) {
            $model->setOriginal($this->originalGroups[$k]);
            $model = $model->syncChanges();
            $model->fireModelEventFromBuilder('updated');
        }
    }

    /**
     * Eagerly load the relationship on a set of models.
     *
     * @param  array  $models
     * @param  string  $name
     * @param  \Closure  $constraints
     * @return array
     */
    protected function eagerLoadRelation(array $models, $name, \Closure $constraints)
    {
        // First we will "back up" the existing where conditions on the query so we can
        // add our eager constraints. Then we will merge the wheres that were on the
        // query back to it in order that any where conditions might be specified.
        $relation = $this->getRelation($name);

        $relation->addEagerConstraints($models);

        $constraints($relation);

        if ($relation->getModel() instanceof ModelFormArray)
            $results = $this->rpcGetCollection($relation, $name);
        else
            $results = $relation->getEager();
        // Once we have the results, we just match those back up to their parent models
        // using the relationship instance. Then we just return the finished arrays
        // of models which have been eagerly hydrated and are readied for return.
        return $relation->match(
            $relation->initRelation($models, $name),
            $results, $name
        );
    }

    public function rpcGetCollection(Relation $relation, string $name): Collection
    {
        $baseQuery = $relation->getBaseQuery();
        $whereCondition = $baseQuery->wheres;
        $groups = $baseQuery->groups;
        $condition = $this->parseWhere($whereCondition, $groups);
        $target = $relation->getModel();
        /**
         * @var Collection $collections
         */
        $collections = $target->rpcGet($name, $condition);
        $this->eagerLoad = $this->relationsNestedUnder($name);

        if ($collections->isNotEmpty()) {
            /**
             * @var Model $model
             */
            $model = $collections->first();
            $buidler = $model->newModelQuery();
            $buidler->setEagerLoads($this->eagerLoad);
            $models = $buidler->eagerLoadRelations($collections->all());
            return $model->newCollection($models);
        }

        return $collections;
    }

    public function getModels($columns = ['*'])
    {
        if ($this->getModel() instanceof ModelFormArray)
            return $this->rpcGetModels($columns, $this->fromPaginator);
        return parent::getModels($columns);
    }

    public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);

        $perPage = $perPage ?: $this->model->getPerPage();

        if ($this->getModel() instanceof ModelFormArray) {
            $this->fromPaginator = true;
            $results = $this->forPage($page, $perPage)->get($columns);
            $total = $this->totalCount;
        } else {
            $results = ($total = $this->toBase()->getCountForPagination())
                ? $this->forPage($page, $perPage)->get($columns)
                : $this->model->newCollection();
        }


        return $this->paginator($results, $total, $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    private function rpcGetModels($columns, $byPage = false)
    {
        $baseQuery = $this->getQuery();
        $whereCondition = $baseQuery->wheres;
        $groups = $baseQuery->groups;
        $condition = $this->parseWhere($whereCondition, $groups);
        $target = $this->getModel();
        $name = $baseQuery->from;

        $collections = $byPage
            ? $target->rpcGetByPage($name, $condition, $byPage)
            : $target->rpcGet($name, $condition, $byPage);

        if ($byPage) {
            /**
             * @var LengthAwarePaginator $collections
             */
            $this->totalCount = $collections->total();
            return $collections->items();
        } else {
            /**
             * @var Collection $collections
             */
            return $collections->all();
        }
    }

    private function parseWhere(array $wheres, $groups = [])
    {
        $condition = [];
        foreach ($wheres as $where) {
            switch ($where['type']) {
                case self::TYPE_IN:
                    $fieldArr = explode('.', $where['column']);
                    $condition[end($fieldArr)] = implode(',', $where['values']);
                    break;
                case self::TYPE_RAW:
                    $fieldArr = $where['sql'];
                    if (stripos($fieldArr, '`') !== false) {
                        $reg = '/`\w+`\./i';
                        $fieldArr = preg_replace($reg, '', $where['sql']);
                    }
                    $condition['_raw'] = $fieldArr;
                    break;
                case self::TYPE_IN_RAW:
                    $field = $where['column'];
                    if (stripos($field, '.') !== false) {
                        $reg = '/\w+\./i';
                        $field = preg_replace($reg, '', $field);
                    }
                    $condition[$field] = implode(',', $where['values']);
                    break;
                default:
                    $fieldArr = explode('.', $where['column']);
                    $condition[end($fieldArr)] = $where['value'];
                    break;
            }
        }
        if (!empty($groups))
            $condition['_group'] = $groups;
        return $condition;
    }
}