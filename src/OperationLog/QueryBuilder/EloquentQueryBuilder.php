<?php
/**
 * Created by PhpStorm.
 * User: $_s
 * Date: 2020/5/12
 * Time: 11:28
 */

namespace LinLancer\Laravel\OperationLog\QueryBuilder;


use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Pagination\Paginator;
use Illuminate\Support\Str;
use LinLancer\Laravel\EloquentModel;
use LinLancer\Laravel\ModelFormArray;
use LinLancer\Laravel\OperationLogger;

class EloquentQueryBuilder extends Builder
{
    const TYPE_IN = 'In';

    const TYPE_RAW = 'raw';

    const TYPE_IN_RAW = 'InRaw';

    private $originalGroups = [];

    private $fromPaginator = false;

    private $totalCount = 0;

    public function update(array $values)
    {
        $model = $this->getModel();
        if ($model instanceof ModelFormArray) {
            return $this->rpcSetData($values);
        }
        if ($model instanceof OperationLogger && $model->exists === false) {
            $models = $this->getModels();
            $this->beforeUpdate($models);
        }
        $result = parent::update($values); // TODO: Change the autogenerated stub
        if ($model instanceof OperationLogger && $model->exists === false) {
            $models = $this->getModels();
            $this->afterUpdate($models);
        }

        return $result;
    }

    public function beforeUpdate(array $models)
    {
        /**
         * @var EloquentModel $model
         */
        foreach ($models as $model) {
            $this->originalGroups[] = $model->getOriginal();
        }
    }

    public function afterUpdate(array $models)
    {
        /**
         * @var EloquentModel $model
         */
        foreach ($models as $k => $model) {
            $model->setOriginal($this->originalGroups[$k]);
            $model = $model->syncChanges();
            $model->fireModelEventFromBuilder('updated');
        }
    }

    /**
     * Eagerly load the relationship on a set of models.
     *
     * @param  array  $models
     * @param  string  $name
     * @param  \Closure  $constraints
     * @return array
     */
    protected function eagerLoadRelation(array $models, $name, \Closure $constraints)
    {
        // First we will "back up" the existing where conditions on the query so we can
        // add our eager constraints. Then we will merge the wheres that were on the
        // query back to it in order that any where conditions might be specified.
        $relation = $this->getRelation($name);

        $relation->addEagerConstraints($models);

        $constraints($relation);

        if ($relation->getModel() instanceof ModelFormArray)
            $results = $this->rpcGetCollection($relation, $name);
        else
            $results = $relation->getEager();
        // Once we have the results, we just match those back up to their parent models
        // using the relationship instance. Then we just return the finished arrays
        // of models which have been eagerly hydrated and are readied for return.
        return $relation->match(
            $relation->initRelation($models, $name),
            $results, $name
        );
    }

    public function rpcGetCollection(Relation $relation, string $name): Collection
    {
        $baseQuery = $relation->getBaseQuery();
        $condition = [
            'wheres' => $baseQuery->wheres,
            'columns' => $baseQuery->columns,
            'groups' => $baseQuery->groups,
            'orders' => $baseQuery->orders,
            'offset' => $baseQuery->offset,
            'limit' => $baseQuery->limit,
            'aggregate' => $baseQuery->aggregate,
            'bindings' => $baseQuery->getRawBindings(),

        ];
        $condition = base64_encode(serialize($condition));
        $target = $relation->getModel();

        /**
         * @var Collection $collections
         */
        $collections = $target->rpcGet($name, $condition, $baseQuery->columns);
        $eagerLoad = $this->relationsNestedUnder($name);
        if ($collections->isNotEmpty() && !empty($eagerLoad)) {
            /**
             * @var Model $model
             */
            $model = $collections->first();
            $buidler = $model->newModelQuery();
            $buidler->setEagerLoads($eagerLoad);
            $models = $buidler->eagerLoadRelations($collections->all());
            return $model->newCollection($models);
        }

        return $collections;
    }

    public function getModels($columns = ['*'])
    {
        if ($this->getModel() instanceof ModelFormArray)
            return $this->rpcGetModels($columns, $this->fromPaginator);
        return parent::getModels($columns);
    }

    public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);

        $perPage = $perPage ?: $this->model->getPerPage();

        if ($this->getModel() instanceof ModelFormArray) {
            $this->fromPaginator = true;
            $results = $this->forPage($page, $perPage)->get($columns);
            $total = $this->totalCount;
        } else {
            $results = ($total = $this->toBase()->getCountForPagination())
                ? $this->forPage($page, $perPage)->get($columns)
                : $this->model->newCollection();
        }


        return $this->paginator($results, $total, $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    private function rpcGetModels($columns, $byPage = false)
    {
        $baseQuery = $this->getQuery();
        $condition = [
            'wheres' => $baseQuery->wheres,
            'columns' => $baseQuery->columns,
            'groups' => $baseQuery->groups,
            'orders' => $baseQuery->orders,
            'offset' => $baseQuery->offset,
            'limit' => $baseQuery->limit,
            'aggregate' => $baseQuery->aggregate,
            'bindings' => $baseQuery->getRawBindings(),

        ];
        $condition = base64_encode(serialize($condition));
        $target = $this->getModel();
        $name = $baseQuery->from;

        $collections = $byPage
            ? $target->rpcGetByPage($name, $condition, $byPage, $baseQuery->columns)
            : $target->rpcGet($name, $condition, $byPage, $baseQuery->columns);

        if ($byPage) {
            /**
             * @var LengthAwarePaginator $collections
             */
            $this->totalCount = $collections->total();
            return $collections->items();
        } else {
            /**
             * @var Collection $collections
             */
            return $collections->all();
        }
    }

    private function rpcSetData($values)
    {
        $baseQuery = $this->getQuery();
        $condition = [
            'wheres' => $baseQuery->wheres,
            'columns' => $baseQuery->columns,
            'groups' => $baseQuery->groups,
            'orders' => $baseQuery->orders,
            'offset' => $baseQuery->offset,
            'limit' => $baseQuery->limit,
            'aggregate' => $baseQuery->aggregate,
            'bindings' => $baseQuery->getRawBindings(),

        ];
        $condition = base64_encode(serialize($condition));
        /**
         * @var ModelFormArray $model
         */
        $model = $this->getModel();

        return $model->rpcSet($baseQuery->from ?? '', $condition, $values);
    }
}